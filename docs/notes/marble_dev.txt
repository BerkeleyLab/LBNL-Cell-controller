Cell Controller marble porting development notes

Badger/BWUDP:
  Default IP address: 192.168.20.20
  Source: [epics.c]
    static const ipv4Address defaultIP = {{192, 168, 20, 20}};
  Default UDP Port: 50006
  Source: [cellControllerProtocol.h]
    #define CC_PROTOCOL_UDP_PORT        50006

Aurora clocks:
  Line rate: Appears to be 3.125 Gb/s (why that number?)
  F_GTREFCLK can be many discrete values from 125 MHz to 625 MHz
    What's the trade-off?
  For marble, I have two options:
    1. Set F_GTREFCLK to 125MHz and use FPGA_REF_CLK0
    2. Generate any other frequency with SI570
  Option 1 sounds easiest.  Any reason why I shouldn't do that?

Aurora packets:
  | Header (4B) | Data X (4B) | Data Y (4B) | Data S (4B) | CRC (4B) |

           31                16          15         14             10     9      8               0
  Header: | Magic 0xA5BE (16b) | FOFB Enabled (1b) | Cell Index (5b) | pad (1b) | FOFB Index (9b) |
  Data X: | ------------------------------- Beam X Position in nm ------------------------------- |
  Data Y: | ------------------------------- Beam Y Position in nm ------------------------------- |
  Data S: | CRC Fault (1b) | ADC Clipping (1b) | --------------- Sum Value (30b) ---------------- |
  CRC:    | ---------------------------------- Aurora CRC Word ---------------------------------- |

Aurora Network Path:
  Modules:
    fofbReadLink:   Reads BPM/CELL packets from AXI stream and stores X/Y/S data
                    Clock domain crossing from auroraUserClk to sysClk via dpram
    fofbReadLinks:  Encapsulates fofbReadLink for both CCW and CW Cell links

  Note: AXI Stream is TDATA (32b), TVALID (1b), TREADY (1b), TLAST (1b)
   system.bd -> fofbReadLinks
  | GTX |

  Important Signals:
    === FAstrobe: Reset data accumulation (from BPM and CELL links) ===
    [evrSync] evrFAmarker->(cross from evrclk to sysclk)->auroraFAstrobe (rising edge detector) [fofbReadLinks] FAstrobe

  Cell CCW Path:
    [forwardCellLink] -> AXI Stream -> [fofbReadLinks] auCellCCWlink_
                                    -> [system.bd] CELL_CCW_AXI_STREAM_TX_

Verilator Live Simulator:
  I want to create a Verilator live simulation which uses UDP ports in place of GTX channels.
  Then I would make a companion test software in C which emulates the environment of the cell
  controller (other cell controllers and BPMs).
  The simulator will operate on AXI Streams rather than on the Aurora encoded GTX bitstream.
  Once the software is done, I could emulate on hardware with an ethernet switch with SFP/QSFP
  fiber ports by adding an Aurora codec layer.
  (Directions below are wrt the simulator, not the companion software)
  Ports:
    Name        Directions  Notes
    BPM CCW     in          Input from BPMs on CCW ring
    BPM CW      in          Input from BPMs on CW ring
    CELL CCW    in/out
    CELL CW     in/out
    GPIO        in/out      Emulate Microblaze transactions on "GPIO_OUT" and "GPIO_IN"

230911:
  The cell controller loop seems to be working well in the testbench.
  Added an incrementing feature to the traffic generator which increments the cell_index
  in any packets that pass through.

230907:
  Trying to get a toehold on this Aurora network testing.
  I'd like to have a testbench which simulates the Aurora loopback.  I think this
  could be accomplished by:
    1. Replacing bd with AXI Stream loopback
    2. Operating at AXI Stream level, not with GTX pins

  AXI Loopback module:
    Connect input CELL_CCW_AXI_STREAM_TX to output CELL_CCW_AXI_STREAM_RX
    Connect input CELL_CW_AXI_STREAM_TX  to output CELL_CW_AXI_STREAM_RX

  BPM Traffic Generator:
    input FAstrobe
    Generate fake packets from "BPMs" and output on both/alternating BPM_CCW_AXI_STREAM_RX and
    BPM_CW_AXI_STREAM_RX
    Generate one packet per BPM in response to FAstrobe

  Cell Traffic Generator:
    input FAstrobe
    If BPM Traffic generator not present/enabled:
      Enable self-increment of packet "Cell Index"
      Generate one fake packet with "Cell Index" = 0 (this will self-increment when received on the loopback)

  GPIO Bus Controller:
    Just set outputs to 0 for now.  In the future, perhaps this can be a Verilator module which
    performs GPIO_OUT transactions in response to UDP commands.

  TODO:
    DONE forwardCellLink.v needs a simulated version of forwardCellLinkMux

230713:
  Jira task list:
    Get QSFP register readout working
    Get fiber connection functioning
    Make single-board fiber loopback on CC link (connect tx to rx)
    Make single-board fiber loopback on BPM link (connect tx to rx)

230707:
  Adding scrap_dev instance to cctrl_marble_top.v using UART pins on Pmod1
  to provide a debug view into memory in the live hardware.  This will ultimately
  be faster and more flexible than hacking the console API.  It should be removed
  before production.
  Added scrap files to Makefile.  Should I submodule it?  Probably if Lucas wants
  to build it as well.

230626:
  After an incredibly annoying bug squash, I was able to change the aurora
  refclk freq to 125 MHz (from 312.5 MHz) and successfully build.  In the
  absence of any compelling reasoning to the contrary, I'm going to attempt
  to require as few different input clock frequencies as possible.
  On the latest (successful) build,
    Included:
      forwardData
      evrSync
      evr_mgt_top_i
      evrLogger
      readBPMlinks
      forwardCellLink
      fofbReadLinks
      linkStatistics
      fofbDSP
    Excluded:
      qsfpReadout
      *psSetpointMonitor
      *psAWG
      *psMUX
      *psTx
      *psRx
      fofbRecorder
      *eebi
      errorConvert

  For the qsfpReadout, I need to add an additional transaction to set the
  configuration of the I2C mux (U5, TCA9548) to select the desired QSFP
  (they can have the same I2C address, so must only enable one channel at
  a time).

230613:
  Ethernet is working now.  I had a few bugs to squash.
  1. Assert PHY_RSTN at top level (I guess it was defaulting to low).
  (now it should ping)
  2. Register service with bwudp using htons(PORT) rather than just PORT
  (now it should respond to packets)
  3. Fix the byte order of sscanf in software/tests/protocolTest.c
  (now we can send a test packet and parse the response)

  Next I'd like to re-introduce some of the modules I excluded from the last
  synthesis and see if I can still build.  If I can introduce modules in the
  smallest increments I should be able to maintain a tractable understanding
  of the clock interactions and the required 

  I also need to figure out the clock situation.

230612:
  First try ethernet is dead.  After setting up route on the lappy, I see the
  lights on the switch blinking on the host side, but not on the marble side.
  Also get no response and no chatter.  Can't ping either.
  Also the marble_mmc MDIO dump is returning all 0xFFFF on all registers.
  I have never experimented with this function, but that can't be accurate.

  Debug steps:
    1. Verify xdc file with schematic (everything going where it needs to?)
    2. Drop in chipscope/ila or scrap memory to log rxd pin activity
    3. Fix the MDIO issue and query those registers
    4. Get some FMC breakout to put the GMII pins on a scope
