// rtefi_blob.v is normally a preprocessed version of rtefi_preblob.v with
// definitions from the include file expressed/expanded.  That include file
// is itself machine-generated based on the desired clients.
//
// TL;DR: if this file is named rtefi_blob.v, it's probably a mistake to
// hand-edit it!
//
// This Verilog include file was machine-generated by /home/kpenney/repos/cell-controller/gateware/submodules/bedrock//badger/collect_clients.py
// 1 /home/kpenney/repos/cell-controller/gateware/submodules/bedrock//badger/hello.v
// filling in unused UDP ports starting at 2












module rtefi_blob(
	// GMII Input (Rx)
	input rx_clk,
	input [7:0] rxd,
	input rx_dv,
	input rx_er,
	// GMII Output (Tx)
	input tx_clk,
	output [7:0] txd,
	output tx_en,
	output tx_er,
	// Configuration
	input enable_rx,
	input config_clk,
	input [3:0] config_a,
	input [7:0] config_d,
	input config_s,  // MAC/IP address write
	input config_p,  // UDP port number write
	// Host side of Tx MAC
	// connect the 2 below to an external 16 bit dual port ram
	output [mac_aw - 1: 0] host_raddr,
	input [15:0] host_rdata,
	// address where we should start transmitting from
	input [mac_aw - 1: 0] buf_start_addr,
	// set start to trigger transmission, wait for done, reset start
	input tx_mac_start,
	output tx_mac_done,
	// port to Rx MAC memory
	output [7:0] rx_mac_d,
	output [11:0] rx_mac_a,
	output rx_mac_wen,
	// port to Rx MAC handshake
	input rx_mac_hbank,
	output [1:0] rx_mac_buf_status,
	// port to Rx MAC packet selector
	output [7:0] rx_mac_status_d,
	output rx_mac_status_s,
	input rx_mac_accept,
	// Debugging
	output [3:0] scanner_debug,
	output ibadge_stb,
	output [7:0] ibadge_data,
	output obadge_stb,
	output [7:0] obadge_data,
	output xdomain_fault,
	// Pass-through to user modules


	// Dumb stuff to get LEDs blinking
	output rx_mon,
	output tx_mon,
	// Simulation-only
	output in_use
);

parameter paw = 11;  // packet (memory) address width, nominal 11
parameter n_lat = 8;  // latency of client pipeline
parameter mac_aw = 10;  // sets size (in 16-bit words) of DPRAM in Tx MAC
// See comments in rtefi_center.v
parameter [31:0] ip = {8'd192, 8'd168, 8'd7, 8'd4};  // 192.168.7.4
parameter [47:0] mac = 48'h12555500012d;
parameter udp_port0 = 7;
parameter udp_port1 = 801;
parameter udp_port2 = 802;
parameter udp_port3 = 803;
parameter udp_port4 = 804;
parameter udp_port5 = 0;
parameter udp_port6 = 0;
parameter udp_port7 = 0;



wire [10:0] len_c;
wire [6:0] raw_l;
wire [6:0] raw_s;
wire [7:0] idata;
wire [7*8-1:0] mux_data_in;

rtefi_center #(
	.ip(ip), .mac(mac), .paw(paw), .n_lat(n_lat),
	.mac_aw(mac_aw),
	.udp_port0(udp_port0),
	.udp_port1(udp_port1),
	.udp_port2(udp_port2),
	.udp_port3(udp_port3),
	.udp_port4(udp_port4),
	.udp_port5(udp_port5),
	.udp_port6(udp_port6),
	.udp_port7(udp_port7)
) center(
	.rx_clk(rx_clk), .rxd(rxd),
	.rx_dv(rx_dv), .rx_er(rx_er),
	.tx_clk(tx_clk) , .txd(txd),
	.tx_en(tx_en),
	.enable_rx(enable_rx),
	.config_clk(config_clk), .config_s(config_s), .config_p(config_p),
	.config_a(config_a), .config_d(config_d),
	.len_c(len_c), .raw_l(raw_l), .raw_s(raw_s),
	.idata(idata), .mux_data_in(mux_data_in),
	.host_raddr(host_raddr),
	.host_rdata(host_rdata),
	.buf_start_addr(buf_start_addr),
	.tx_mac_start(tx_mac_start),
	.tx_mac_done(tx_mac_done),
	.rx_mac_d(rx_mac_d), .rx_mac_a(rx_mac_a), .rx_mac_wen(rx_mac_wen),
	.rx_mac_hbank(rx_mac_hbank), .rx_mac_buf_status(rx_mac_buf_status),
	.rx_mac_accept(rx_mac_accept),
	.rx_mac_status_d(rx_mac_status_d), .rx_mac_status_s(rx_mac_status_s),
	.scanner_debug(scanner_debug),
	.ibadge_stb(ibadge_stb), .ibadge_data(ibadge_data),
	.obadge_stb(obadge_stb), .obadge_data(obadge_data),
	.xdomain_fault(xdomain_fault),
	.rx_mon(rx_mon), .tx_mon(tx_mon), .in_use(in_use)
);

wire clk = tx_clk;
wire [7:0] odata_p7, odata_p6, odata_p5, odata_p4, odata_p3, odata_p2, odata_p1;
assign mux_data_in = {odata_p7, odata_p6, odata_p5, odata_p4, odata_p3, odata_p2, odata_p1};
assign tx_er = 1'b0;


hello #(.n_lat(n_lat)) p1_client(.clk(clk), .len_c(len_c), .idata(idata), .raw_l(raw_l[0]), .raw_s(raw_s[0]), .odata(odata_p1));
assign odata_p2 = 8'h32;
assign odata_p3 = 8'h33;
assign odata_p4 = 8'h34;
assign odata_p5 = 8'h35;
assign odata_p6 = 8'h36;
assign odata_p7 = 8'h37;

endmodule
// Full RTEFI Rx/Tx pipeline
//
// Ports are abstract GMII (maybe should adjust their names?).
// Non-GMII hardware can and should add an adapter layer to get
// from GMII to RGMII or the MGT.  Actual GMII hardware can just
// connect these ports to the physical pins.
//
// Up to seven clients, each handling a UDP port, attach here.
//
// This module instantiates a series of modules for the data path
// linking GMII Rx through to GMII Tx, shown in doc/rtefi.eps.
// The several steps have instance names starting with a through e
// (a_scan through e_crc).
//
module rtefi_center(
	// GMII Input (Rx)
	input rx_clk,
	input [7:0] rxd,
	input rx_dv,
	input rx_er,
	// GMII Output (Tx)
	input tx_clk,
	output [7:0] txd,
	output tx_en,
	// Configuration
	input enable_rx,
	input config_clk,
	input [3:0] config_a,
	input [7:0] config_d,
	input config_s,  // MAC/IP address write
	input config_p,  // UDP port number write
	// Host side of Tx MAC
	// connect the 2 below to an external 16 bit dual port ram
	output [mac_aw - 1: 0] host_raddr,
	input [15:0] host_rdata,
	// address where we should start transmitting from
	input [mac_aw - 1: 0] buf_start_addr,
	// set start to trigger transmission, wait for done, reset start
	input tx_mac_start,
	output tx_mac_done,
	// As documented in doc/clients.eps
	output [10:0] len_c,
	output [6:0] raw_l,
	output [6:0] raw_s,
	output [7:0] idata,
	input [7*8-1:0] mux_data_in,  // collection of odata
	// port to Rx MAC memory
	output [7:0] rx_mac_d,
	output [11:0] rx_mac_a,
	output rx_mac_wen,
	// port to Rx MAC handshake
	input rx_mac_hbank,
	output [1:0] rx_mac_buf_status,
	// port to Rx MAC packet selector
	input rx_mac_accept,
	output [7:0] rx_mac_status_d,
	output rx_mac_status_s,
	// Debugging
	output ibadge_stb,
	output [7:0] ibadge_data,
	output obadge_stb,
	output [7:0] obadge_data,
	output xdomain_fault,
	// Dumb stuff to get LEDs blinking
	output [3:0] scanner_debug,
	output rx_mon,
	output tx_mon,
	// Simulation-only
	output in_use
);

parameter paw = 11;  // packet (memory) address width, nominal 11
parameter n_lat = 3;  // latency of client pipeline
parameter mac_aw = 10;  // sets size (in 16-bit words) of DPRAM in Tx MAC
parameter handle_arp = 1;
parameter handle_icmp = 1;
// The following parameters set the synthesis-time default, but all
// can be overridden at run-time using the configuration port.
// UDP ports 0 through 7 represent the index given in udp_sel.
// While udp_port_cam.v is written parameterized, we limit it to
// three bits and 8 ports for timing reasons.  Port 0 is internally
// implemented as echo; the rest will be user-defined via synthesis-time
// plug-ins.  Generally the UDP port numbers should be "well known",
// but the case can be made to have them run-time override-able (without
// resynthesizing) to help cope with unexpected network issues.
parameter [31:0] ip = {8'd192, 8'd168, 8'd7, 8'd4};  // 192.168.7.4
parameter [47:0] mac = 48'h12555500012d;
parameter udp_port0 = 7;
parameter udp_port1 = 801;
parameter udp_port2 = 802;
parameter udp_port3 = 803;
parameter udp_port4 = 0;
parameter udp_port5 = 0;
parameter udp_port6 = 0;
parameter udp_port7 = 0;

// Overhead: make sure the tools can create an IOB on all GMII inputs
reg [7:0] eth_in_r=0;
reg eth_in_s_r=0, eth_in_e_r=0;
always @(posedge rx_clk) begin
	eth_in_r <= rxd;
	eth_in_s_r <= rx_dv;
	eth_in_e_r <= rx_er;
end

// First real step: scan the input packet
wire [3:0] ip_a;  reg [7:0] ip_d=0;  // MAC/IP config, Rx side
wire [3:0] pno_a; reg [7:0] pno_d;  // UDP port numbers
wire [7:0] sdata;
wire scanner_busy;
wire sdata_s, sdata_l;
wire [10:0] pack_len;
wire [7:0] status_vec; wire status_valid;
scanner #(.handle_arp(handle_arp), .handle_icmp(handle_icmp)) a_scan(
	.clk(rx_clk),
	.eth_in(eth_in_r), .eth_in_s(eth_in_s_r), .eth_in_e(eth_in_e_r),
	.enable_rx(enable_rx),
	.ip_a(ip_a), .ip_d(ip_d),
	.pno_a(pno_a), .pno_d(pno_d),
	.busy(scanner_busy), .debug(scanner_debug),
	.odata(sdata), .odata_s(sdata_s), .odata_f(sdata_l),
	.pack_len(pack_len), .status_vec(status_vec), .status_valid(status_valid)
);
assign rx_mac_status_d = status_vec;
assign rx_mac_status_s = status_valid;

// Second step: create data flow to DPRAM
wire [paw-1:0] pbuf_a_rx, gray_state;
wire [8:0] pbuf_din;
pbuf_writer #(.paw(paw)) b_write(.clk(rx_clk),
	.data_in(sdata), .data_s(sdata_s), .data_f(sdata_l),
	.pack_len(pack_len), .status_vec(status_vec), .status_valid(status_valid),
	.mem_a(pbuf_a_rx), .mem_d(pbuf_din),
	.rx_mac_d(rx_mac_d), .rx_mac_a(rx_mac_a), .rx_mac_wen(rx_mac_wen),
	.rx_mac_hbank(rx_mac_hbank), .rx_mac_buf_status(rx_mac_buf_status),
	.rx_mac_accept(rx_mac_accept),
	.gray_state(gray_state),
	.badge_stb(ibadge_stb)
);
assign ibadge_data = pbuf_din;

// 1 MTU DPRAM; note the ninth bit used to mark Start of Frame.
// Also note the lack of a write-enable, just write every cycle.
reg [8:0] pbuf[0:(1<<paw)-1];
reg [8:0] pbuf_out;

initial pbuf_out=0;

wire [paw-1:0] mem_a2;  // see below
always @(posedge rx_clk) pbuf[pbuf_a_rx] <= pbuf_din;
always @(posedge tx_clk) pbuf_out <= pbuf[mem_a2];
integer jx;
initial for (jx=0; jx<(1<<paw); jx=jx+1) pbuf[jx]=0;

// Third step, sift through that packet's data to
// synthesize the reply packet's header
wire [3:0] ip_mem_a_tx;  reg[7:0] ip_mem_d_tx=0;  // MAC/IP config, Tx side
// Signals sent from construct to xformer
wire [5:0] pc;
wire [1:0] category;
wire [2:0] udp_sel;
wire [7:0] eth_data_out;
wire eth_strobe_short, eth_strobe_long;
localparam p_offset=480;  // see notes in construct.v
construct #(.paw(paw), .p_offset(p_offset)) c_construct(.clk(tx_clk),
	.gray_state(gray_state),
	.ip_a(ip_mem_a_tx), .ip_d(ip_mem_d_tx),
	.addr(mem_a2), .pbuf_out(pbuf_out),
	.pc(pc), .category(category), .udp_sel(udp_sel),
	.badge_stb(obadge_stb), .badge_data(obadge_data),
	.xdomain_fault(xdomain_fault),
	.eth_data_out(eth_data_out), .eth_strobe_short(eth_strobe_short), .eth_strobe_long(eth_strobe_long)
);

// Data multiplexer
wire xraw_s, xraw_l;  wire [7:0] raw_d;  // Output, still needs CRC
xformer #(.n_lat(n_lat), .handle_icmp(handle_icmp)) d_xform(.clk(tx_clk),
	.pc(pc), .category(category), .udp_sel(udp_sel),
	.idata(eth_data_out), .eth_strobe_short(eth_strobe_short), .eth_strobe_long(eth_strobe_long),
	.len_c(len_c),
	.raw_l(raw_l), .raw_s(raw_s),
	.mux_data_in(mux_data_in),
	.odata(raw_d), .ostrobe_s(xraw_s), .ostrobe_l(xraw_l)
);
assign idata = eth_data_out;

// Tx MAC
// Disable by setting mac_aw=1
// precog_latency is kind of important;
// check resulting interpacket gap in simulations
localparam precog_latency = (1<<paw) - p_offset + 4 + n_lat;
wire [7:0] tx_mac_data;
wire tx_mac_strobe_s, tx_mac_strobe_l;
generate if (mac_aw > 1) begin: mac_b
    mac_subset #(
	.mac_aw(mac_aw),
	.latency(precog_latency)
    ) txmac (
	.host_raddr(host_raddr),
	.host_rdata(host_rdata),
	.buf_start_addr(buf_start_addr),
	.tx_mac_start(tx_mac_start),
	.tx_mac_done(tx_mac_done),
	.scanner_busy(scanner_busy),
	.tx_clk(tx_clk),
	.mac_data(tx_mac_data),
	.strobe_s(tx_mac_strobe_s),
	.strobe_l(tx_mac_strobe_l)
    );
end else begin
	assign tx_mac_strobe_s = 0;
	assign tx_mac_strobe_l = 0;
	assign tx_mac_data = 0;
end endgenerate

// Slide data from Tx MAC in here
// XXX no cross-checking that the MAC is avoiding collisions
// using precog the way it's supposed to.
wire xraw2_s = xraw_s | tx_mac_strobe_s;
wire xraw2_l = xraw_l | tx_mac_strobe_l;
wire [7:0] raw2_d = tx_mac_strobe_s ? tx_mac_data : raw_d;

// Finally, add Ethernet CRC and GMII preamble
wire opack_s;  wire [7:0] opack_d;
ethernet_crc_add e_crc(.clk(tx_clk),
	.raw_s(xraw2_s), .raw_l(xraw2_l), .raw_d(raw2_d),
	.opack_s(opack_s), .opack_d(opack_d)
);

// Make sure these outputs can be put into an IOB
reg [7:0] eth_out_r=0;
reg eth_out_s_r=0;
always @(posedge tx_clk) begin
	eth_out_r <= opack_d;
	eth_out_s_r <= opack_s;
end
assign txd = eth_out_r;
assign tx_en = eth_out_s_r;

// Has to be distinct from the IOBs
assign rx_mon = eth_in_s_r;
assign tx_mon = opack_s;

// Hook for testing, not intended to be connected in hardware
reg [paw-1:0] in_use_timer=0;
assign in_use = |in_use_timer;
always @(posedge rx_clk) begin
	if (in_use) in_use_timer <= in_use_timer - 1;
	if (rx_mon) in_use_timer <= {paw{1'b1}};
end

// Memory for MAC/IP addresses
reg [7:0] ip_mem[0:15];
always @(posedge config_clk) if (config_s) ip_mem[config_a] <= config_d;
always @(posedge rx_clk) ip_d <= ip_mem[ip_a];
always @(posedge tx_clk) ip_mem_d_tx <= ip_mem[ip_mem_a_tx];
initial begin
	// Matches packets in at least arp3.dat, icmp3.dat, udp3.dat.
	ip_mem[0] = mac[47:40];  // Start of MAC
	ip_mem[1] = mac[39:32];
	ip_mem[2] = mac[31:24];
	ip_mem[3] = mac[23:16];
	ip_mem[4] = mac[15:8];
	ip_mem[5] = mac[7:0];  // End of MAC
	ip_mem[6] = ip[31:24];  // Start of IP
	ip_mem[7] = ip[23:16];
	ip_mem[8] = ip[15:8];
	ip_mem[9] = ip[7:0];  // End of IP
end

// Memory for UDP port numbers
reg [7:0] pno_mem[0:15];
always @(posedge config_clk) if (config_p) pno_mem[config_a] <= config_d;
always @(posedge rx_clk) pno_d <= pno_mem[pno_a];
initial begin
	pno_mem[0] = udp_port0[15:8];
	pno_mem[1] = udp_port0[7:0];
	pno_mem[2] = udp_port1[15:8];
	pno_mem[3] = udp_port1[7:0];
	pno_mem[4] = udp_port2[15:8];
	pno_mem[5] = udp_port2[7:0];
	pno_mem[6] = udp_port3[15:8];
	pno_mem[7] = udp_port3[7:0];
	pno_mem[8] = udp_port4[15:8];
	pno_mem[9] = udp_port4[7:0];
	pno_mem[10] = udp_port5[15:8];
	pno_mem[11] = udp_port5[7:0];
	pno_mem[12] = udp_port6[15:8];
	pno_mem[13] = udp_port6[7:0];
	pno_mem[14] = udp_port7[15:8];
	pno_mem[15] = udp_port7[7:0];
end

endmodule
// scans input packet

// status_vec key:
// assign status_vec = {port_p, pass_ip, pass_ethmac, crc_zero, category};
//  bit 0-1  category: 3=UDP, 2=ICMP, 1=ARP, 0=other
//  bit 2  CRC32 passed
//  bit 3  Destination MAC matched our configuration
//  bit 4  valid IP packet of some kind
//  bit 5-7  UDP virtual port number, output of CAM

// I haven't yet started trying to handle authentication here.
// That can wait; we have the architecture ready.

// This is a relatively long file, but it helps that it is broken down
// into smaller modules:
//   scanner   top level, see doc/rtefi.eps
//    - arp_patt
//    - ip_patt
//    - icmp_patt
//    - udp_patt
// The four submodules have relatively consistent ports and semantics.

module scanner (
	input clk,
	input [7:0] eth_in,
	input eth_in_s,
	input eth_in_e,  // error flag from PHY
	// PSPEPS didn't do anything with eth_in_e, which is certainly
	// a mistake, but did work in practice.  Let's get this code working
	// and basically tested before adding that new feature.
	//
	// New port: async input to allow packet reception
	// Lets someone turn off the Ethernet subsystem during maintenance,
	// e.g., changing IP address.
	input enable_rx,
	// port to MAC/IP config, single-cycle latency
	output [3:0] ip_a,
	input [7:0] ip_d,
	// port to UDP port number config memory, single-cycle latency
	output [3:0] pno_a,
	input [7:0] pno_d,
	// Access to a single-cycle-latency RAM holding keys and masks,
	// necessarily also in the Rx clock domain.
	// output [9:0] key_addr,
	// input [15:0] key_data,
	//
	// Two-bit summary info available to precog
	// For a kept packet, busy has the full width of odata_s,
	// but is delayed one cycle.  Non-keep packets can have the busy
	// line de-asserted as soon as the dropping condition is detected.
	// When an incoming packet is categorized as causing a response,
	// the keep line is asserted one cycle before busy falls.
	// Also see doc/precog_upg.eps
	output busy,
	output keep,
	output [3:0] debug,
	//
	// Simple flow of data to the next processing stage (pbuf_writer).
	// somewhat conforms to AXI-stream-lite, if I adjust the names?
	output [7:0] odata,
	output odata_s,
	output odata_f,
	output status_valid,
	output [7:0] status_vec,
	output [10:0] pack_len
);
// Configuration
parameter handle_arp = 1;
parameter handle_icmp = 1;

// State machine mostly cribbed from head_rx.v
wire [7:0] eth_octet = eth_in;
wire eth_strobe = eth_in_s;
// exactly four states, one-hot encoded
reg h_idle=1, h_preamble=0, h_data=0, h_drop=0;
wire drop_packet;
reg [3:0] ifg_count=0;  // Inter-frame gap counter
wire ifg_inc = ~(&ifg_count[3:2]);  // saturate at 12
wire ifg_ok = ifg_count >= 10;  // slightly relaxed from spec of 12,
// this configuration guarantees 11 non-data cycles between frames
always @(posedge clk) begin
	if (h_idle | h_preamble) ifg_count <= ifg_count + ifg_inc;
	else ifg_count <= 0;
	if (h_idle & eth_strobe) begin
		h_idle <= 0;
		if (eth_octet==8'h55 && enable_rx) h_preamble <= 1;
		else h_drop <= 1;
	end
	if (h_preamble) begin
		if (eth_strobe & (eth_octet==8'hd5)) begin
			h_preamble <= 0;
			if (ifg_ok) h_data <= 1;
			else h_drop <= 1;  // IFG too small.
		end else if (eth_strobe & (eth_octet!=8'h55)) begin
			h_preamble <= 0; h_drop <= 1;
		end else if (~eth_strobe) begin
			h_preamble <= 0; h_idle <= 1;
		end
	end
	if (h_data) begin
		if (~eth_strobe) begin
			h_data <= 0; h_idle <= 1;
		end else if (drop_packet) begin   // poorly tested
			h_data <= 0; h_drop <= 1;
		end
	end
	if (h_drop & ~eth_strobe) begin
		h_drop <= 0; h_idle <= 1;
	end
end

// Debug helper
reg [1:0] debug1_r=0;
always @(posedge clk) begin
	if (h_idle) debug1_r <= 0;
	if (h_preamble) debug1_r <= 1;
	if (h_data) debug1_r <= 3;
	if (h_drop) debug1_r <= 2;
end

// Synchronization and pipelining step
// Squelch data that isn't being considered
reg h_data_d1=0, h_data_d2=0, data_first=0;
reg [7:0] data_d1=0, data_d2=0;
always @(posedge clk) begin
	h_data_d1 <= h_data;
	h_data_d2 <= h_data & h_data_d1;  // XXX horrible hack
	// Why does h_data last one octet past last Ethernet octet in data?
	data_first <= h_data & ~h_data_d1;
	data_d1 <= eth_strobe ? eth_octet : 8'b0;
	data_d2 <= data_d1;
end

// Unified handling of MAC/IP addresses via external config memory
//
// Ethernet
// Dest    MAC:  octets 0-5    match me (might be FF for broadcast)
// Source  MAC:  octets 6-11
//
// ARP (RFC 826)
// Sender  MAC:  octets 22-27
// Sender   IP:  octets 28-31
// Placeholder:  octets 32-37
// Dest     IP:  octets 38-41  match me
//
// IP (RFC 791)
// Source   IP:  octets 26-29
// Dest     IP:  octets 30-33  match me
//
// ICMP (RFC 792)
// UDP (RFC 768)
//
reg [10:0] pack_cnt=0;
always @(posedge clk) begin
	pack_cnt <= h_data ? pack_cnt+1 : 0;
end
assign drop_packet = pack_cnt >= 1536;
assign ip_a = pack_cnt > 36 || pack_cnt < 16 ? pack_cnt[3:0] : pack_cnt[3:0]+8;
wire ip_m = ip_d == data_d1;
// This pack_cnt decoding is synthesizable as is; we can make it more gate-
// efficient later, using synthesis measurements and good regression tests.
reg want_c_eth=0, want_c_arp=0, want_c_ip=0;
always @(posedge clk) begin
	want_c_eth <= pack_cnt < 6;
	want_c_arp <= pack_cnt >= 38 && pack_cnt < 42;
	want_c_ip  <= pack_cnt >= 30 && pack_cnt < 34;
end
// Accumulate state
wire pz = pack_cnt == 0;
reg pass_ethmac=0;  always @(posedge clk) begin if (want_c_eth & ~ip_m) pass_ethmac <= 0; if (pz) pass_ethmac <= 1; end
reg pass_arpip=0;   always @(posedge clk) begin if (want_c_arp & ~ip_m) pass_arpip  <= 0; if (pz) pass_arpip  <= 1; end
reg pass_ipdst=0;   always @(posedge clk) begin if (want_c_ip  & ~ip_m) pass_ipdst  <= 0; if (pz) pass_ipdst  <= 1; end

// Specific protocols; IP is a component of both ICMP and UDP
wire [15:0] ip_length, udp_length;

wire pass_arp0;
generate if (handle_arp) begin: find_arp
	arp_patt arp_p (.clk(clk), .cnt(pack_cnt), .data(data_d1), .pass(pass_arp0));
end else assign pass_arp0 = 0;
endgenerate

wire pass_icmp0;
generate if (handle_icmp) begin: find_icmp
	icmp_patt icmp_p(.clk(clk), .cnt(pack_cnt), .data(data_d1), .pass(pass_icmp0));
end else assign pass_icmp0 = 0;
endgenerate

wire pass_ip0;   ip_patt   ip_p  (.clk(clk), .cnt(pack_cnt), .data(data_d1), .pass(pass_ip0), .length(ip_length));
wire pass_udp0;  udp_patt  udp_p (.clk(clk), .cnt(pack_cnt), .data(data_d1), .pass(pass_udp0), .length(udp_length));
wire pass_sum;   cksum_chk chk_p (.clk(clk), .cnt(pack_cnt), .data(data_d1), .pass(pass_sum), .length(ip_length));

// CRC32
wire crc_zero;
crc8e_guts crc8e(.clk(clk), .gate(h_data_d1), .first(data_first),
	.d_in(data_d1), .zero(crc_zero));
wire final_octet = h_data_d1 & ~h_data;

// UDP port number
reg udp_port_stb=0;
always @(posedge clk) udp_port_stb <= pack_cnt == 36;
wire [2:0] port_p0;  wire port_h, port_v;
udp_port_cam #(.naw(3)) cam(.clk(clk),
	.port_s(udp_port_stb), .data(data_d1),
	.pno_a(pno_a), .pno_d(pno_d),
	.port_p(port_p0), .port_h(port_h), .port_v(port_v)
);

// Packet length (doesn't count GMII preamble)
reg [10:0] pack_len_r=0;
always @(posedge clk) if (h_data) pack_len_r <= pack_cnt;

// Weird place for this
reg ip_len_check=0, udp_len_check=0;
always @(posedge clk) if (h_data) begin
	ip_len_check <= pack_cnt >= ip_length + 18; // 18 = 14 Ethernet header + 4 CRC
	udp_len_check <= ip_length >= udp_length + 20; // 20 = IP header length
end

// One more oddball
reg unicast_src_mac=0;
always @(posedge clk) begin
	if (pack_cnt==1) unicast_src_mac <= 1;  // optimistic, needed to make busy flag work
	if (pack_cnt==7) unicast_src_mac <= ~data_d1[0];
end

// Summary bits don't leak irrelevant state
wire pass_arp  = unicast_src_mac & crc_zero & pass_arp0 & pass_arpip;
wire pass_ip   = unicast_src_mac & crc_zero & pass_ethmac & pass_ip0 & pass_ipdst & ip_len_check;
wire pass_icmp = pass_ip & pass_icmp0 & pass_sum;
wire pass_udp  = pass_ip & pass_udp0 & udp_len_check & port_h;
wire [1:0] category = pass_udp ? 3 : pass_icmp ? 2 : pass_arp ? 1 : 0;
wire [2:0] port_p = pass_udp ? port_p0 : 3'd0;

// Summary output
assign status_vec = {port_p, pass_ip, pass_ethmac, crc_zero, category};
assign status_valid = final_octet;
assign pack_len = pack_len_r;

// Other summary output
wire busy_with_arp = unicast_src_mac & pass_arp0;
wire busy_with_udp = unicast_src_mac & pass_ethmac & pass_ip0 & pass_udp0;
wire busy_with_icmp = unicast_src_mac & pass_ethmac & pass_ip0 & pass_icmp0;
reg busy_r=0, keep_r=0;
always @(posedge clk) begin
	busy_r <= odata_s & (busy_with_arp | busy_with_udp | busy_with_icmp);
	keep_r <= odata_s & (category != 0);
end
assign busy = busy_r;
assign keep = keep_r;

// Debug helper
reg [1:0] debug2_r=0;
always @(posedge clk) begin
	if (status_valid) debug2_r <= category;
end
assign debug = {debug2_r, debug1_r};

// Output ports
assign odata = data_d2;
assign odata_s = h_data_d2;
assign odata_f = final_octet;

endmodule

// New modules to get new name spaces

// =====
// UDP/ICMP Checksum checker
// Calculation structure is about the same, superficially looks like
// we just need a little stream selection logic based on the protocol,
// and a single one's-complement accumulator can handle both cases.
// This rosy scenario is stymied by UDP's pathological inclusion of
// _two_ copies of the UDP length.  At the moment, therefore, this
// module doesn't handle UDP.
module cksum_chk(
	input clk,
	input [10:0] cnt,
	input [7:0] data,
	input [15:0] length,  // IP length
	output pass
);

wire chksum_zero = cnt == 22;  // or earlier
wire icmp_gate = cnt >= 35;
// wire udp_gate = cnt >= 23;
wire chksum_gate = icmp_gate;

// Make sure length is known before using it
wire end_of_ip = cnt>32 && cnt == (length+14);

// Standard one's-complement checksum
wire ones;
ones_chksum ck(.clk(clk), .clear(chksum_zero), .gate(chksum_gate),
	.din(data), .all_ones(ones));

// Final state, should find FF FF at end of IP packet
reg eof=0, state=0;
always @(posedge clk) begin
	if (chksum_zero) state <= 0;
	if (end_of_ip) state <= ones;
	eof <= end_of_ip;
	if (eof) state <= state & ones;
end
assign pass = state;

endmodule // UDP/ICMP Checksum checker

// =====
// ARP pattern checker
module arp_patt(
	input clk,
	input [10:0] cnt,
	input [7:0] data,
	output pass
);

reg [7:0] template;
always @(posedge clk) case(cnt[3:0])
	// template starts at 12th byte of Ethernet packet,
	// after the two MAC addresses.
	4'd12: template <= 8'h08;
	4'd13: template <= 8'h06;
	4'd14: template <= 8'h00;   // ARP Ethernet hardware, octet 1
	4'd15: template <= 8'h01;   // ARP Ethernet hardware, octet 2
	4'd00: template <= 8'h08;   // ARP Protocol IP
	4'd01: template <= 8'h00;   // ARP Protocol IP
	4'd02: template <= 8'h06;   // ARP protocol address length
	4'd03: template <= 8'h04;   // ARP protocol address length
	4'd04: template <= 8'h00;   // ARP protocol operation
	4'd05: template <= 8'h01;   // ARP protocol operation (request)
	default: template <= 8'h00;
endcase

reg want=0, pass_r=0;
wire match = data == template;
always @(posedge clk) begin
	want <= cnt >= 12 && cnt < 22;
	if (cnt == 0) pass_r <= 1;
	if (want & ~match) pass_r <= 0;
end
assign pass = pass_r;

endmodule  // ARP pattern checker

// =====
// IP pattern checker
module ip_patt(
	input clk,
	input [10:0] cnt,
	input [7:0] data,
	output pass,
	output [15:0] length
);

reg [7:0] template;
always @(posedge clk) case(cnt[4:0])
	// template starts at 12th byte of Ethernet packet,
	// after the two MAC addresses.
	5'd12: template <= 8'h08;  // Bytes 12 and 13 are Ethertype IPv4
	5'd13: template <= 8'h00;  // https://en.wikipedia.org/wiki/Ethertype

	// Start of IPv4 header [https://en.wikipedia.org/wiki/IPv4#Header]
	5'd14: template <= 8'h45;  // Vers (4 for ipv4) / IHL (> 5 is a weird case)
	// 15  ignore  TOS (later changed to DSCP and ECN)
	// 16  ignore  length msb
	// 17  ignore  length lsb
	// 18  ignore  identification msb
	// 19  ignore  identification lsb
	5'd20: template <= 8'h00;  // Flags/Fragment
	5'd21: template <= 8'h00;
	// 22  ignore  TTL (but see below)
	// 23  ignore  Protocol
	// 24-33  header checksum, source address, destination address
	default: template <= 8'h00;
endcase

// Packet has expired when TTL hits zero
reg ttl_flag=0;
wire zero_ttl = ttl_flag & ~(|data);

reg want=0, mask_df_bit=0, pass_r=0;
wire [7:0] df_mask = {1'b1, ~mask_df_bit, 6'h3f};
wire match = (data&df_mask) == template;
always @(posedge clk) begin
	want <= cnt >= 12 && cnt < 15 || cnt >= 20 && cnt < 22;
	mask_df_bit <= cnt == 20;
	ttl_flag <= cnt == 22;
	if (cnt == 0) pass_r <= 1;
	if (want & ~match) pass_r <= 0;
	if (zero_ttl) pass_r <= 0;
end

// IP packet total length
// Quoting RFC 791, Total Length is the length of the datagram,
// measured in octets, including internet header and data.
reg [7:0] data_d=0;
reg [15:0] length_r=0;
always @(posedge clk) begin
	data_d <= data;
	if (cnt==18) length_r <= {data_d, data};
end
assign length = length_r;

// IP header checksum
reg out_chksum_gate=0, out_chksum_zero=0;
always @(posedge clk) begin
	out_chksum_gate <= cnt >= 14 && cnt < 34;
	out_chksum_zero <= cnt == 0;
end
wire chksum_all_ones;
ones_chksum ck(.clk(clk), .clear(out_chksum_zero), .gate(out_chksum_gate),
	.din(data), .all_ones(chksum_all_ones));
reg chksum_all_ones_d=0;
reg chksum_fail=0;
always @(posedge clk) begin
	chksum_all_ones_d <= chksum_all_ones;
	if (cnt==0) chksum_fail <= 0;
	if (cnt==35) chksum_fail <= ~chksum_all_ones | ~chksum_all_ones_d;
end
assign pass = pass_r & ~chksum_fail;

endmodule  // IP header

// =====
// ICMP pattern checker
// For ICMP checksum see module cksum_chk
module icmp_patt(
	input clk,
	input [10:0] cnt,
	input [7:0] data,
	output pass
);

reg [7:0] template;
always @(posedge clk) case(cnt[2:0])
	// Ethernet/IP header is not in our scope
	// template starts at 23rd byte of Ethernet packet,
	// after the two MAC addresses.
	3'd7: template <= 8'h01;  // cnt==23, Proto (ICMP)
	3'd2: template <= 8'h08;  // cnt==34, ICMP echo request
	3'd3: template <= 8'h00;  // cnt==35, ICMP code
	default: template <= 8'h00;
endcase

reg want=0, pass_r=0;
wire match = data == template;
always @(posedge clk) begin
	want <= cnt == 23 || cnt==34 || cnt==35;
	if (cnt == 0) pass_r <= 1;
	if (want & ~match) pass_r <= 0;
end
assign pass = pass_r;

endmodule  // ICMP pattern checker

// =====
// UDP pattern checker
module udp_patt(
	input clk,
	input [10:0] cnt,
	input [7:0] data,
	output pass,
	output [15:0] length
);

// Degenerate form of template ROM
// Moving this template and comparison to ip_patt would save 2 LUTs.
wire [7:0] template = 8'h11;  // cnt==23, Proto (UDP)

// Reject packets from source port number < 1024,
// as they come from "trusted" sources.
// This is part of the strategy to resist echo loops.
wire reject_low = cnt==35 & ~|data[7:2];

// Reject packets to destination port number 0
reg pzero_d=0, pzero_d1=0, pzero_t=0;
always @(posedge clk) begin
	pzero_d <= data == 8'h00;
	pzero_d1 <= pzero_d;
	pzero_t <= cnt == 36;
end
wire discard_port0 = pzero_t & pzero_d & pzero_d1;

reg want=0, pass_r=0;
wire match = data == template;
always @(posedge clk) begin
	want <= cnt == 23;
	if (cnt == 0) pass_r <= 1;
	if (want & ~match) pass_r <= 0;
	if (reject_low) pass_r <= 0;
	if (discard_port0) pass_r <= 0;
end
assign pass = pass_r;

// UDP packet length
// Length is the length in octets of this user datagram including [UDP]
// header and the data.
reg [7:0] data_d=0;
reg [15:0] length_r=0;
always @(posedge clk) begin
	data_d <= data;
	if (cnt==40) length_r <= {data_d, data};
end
assign length = length_r;

// XXX We don't yet compute the UDP checksum.
// That may not be a practical problem.

endmodule  // UDP pattern checker
// Takes results from scanner and forms the 9-bit output stream for
// the packet buffer, according to the plan shown in doc/memory.eps.
// Five-word "badge" written at the beginning of a packet:
//   1. Dummy, needed in case construct.v skips forward two
//   2. Length msb
//   3. Length lsb
//   4. Status
//   5. Reserved, currently zero
// .. where words 1 and 2 have the 9th bit set to mark start-of-frame.
// This structure must be kept consistent with decoder in construct.v.
//
// The datapath for the packet buffer data is reused to also produce
// a port that can write data to an Rx MAC.  A 4 kByte buffer memory
// is the smallest that can guarantee holding two full packets, and
// we simply double buffer instead of trying something more complicated.

module pbuf_writer #(
	parameter paw=11  // packet address width, 11 IRL, maybe less for simulations
) (
	input clk,
	// Simple flow of data from input state machine
	// conforms to AXI-stream-lite, if I adjust the names?
	input [7:0] data_in,
	input data_s,
	input data_f,
	// Results of scanning process provided to us
	input [10:0] pack_len,
	input [7:0] status_vec,
	input status_valid,
	// port to DPRAM, write every cycle
	output [8:0] mem_d,
	output [paw-1:0] mem_a,
	// port to Rx MAC memory
	output [7:0] rx_mac_d,
	output [11:0] rx_mac_a,
	output rx_mac_wen,
	// port to Rx MAC handshake
	// Double buffering works as follows from the host point of view:
	//   * rx_mac_buf_status = [rx_mac_hbank_r, mac_bank]
	//   * rx_mac_hbank_r = points to the bank currently read (and blocked) by the host
	//     mac_bank = points to the bank the badger will write the next packet to (highest address bit)
	//  1) badger toggles mac_bank once a packet has been completely received
	//  2) The host knows new data is available when rx_mac_hbank_r == mac_bank
	//  3) Host toggles rx_mac_hbank and is allowed to read the slot indexed by rx_mac_hbank_r in the next cycle
	//  4) This allows badger to receive and write to the other slot, cycle continues from 1
	input rx_mac_hbank,
	output [1:0] rx_mac_buf_status,
	// port to Rx MAC packet selector
	input rx_mac_accept,
	// Other
	output [paw-1:0] gray_state,  // Valid read pointer, Rx needs to know this
	output badge_stb  // debugging hook
);

// Possibly stupid waste of 8 FF, but makes development much easier
reg [7:0] status_r=0;
always @(posedge clk) if (status_valid) status_r <= status_vec;

// Synthesize address and data for output DPRAM.
// It's critical that we're able to fill in the badge once the packet has ended.
// See doc/memory.eps for a simplified description of what we're trying to accomplish.
reg [paw-1:0] fp=0;   // unperturbed frame counter/pointer
reg [paw-1:0] fpp=0;  // actual destination address
reg [paw-1:0] origin=0;  // pointer to start of badge
reg [2:0] post_cnt=5;
reg [8:0] pxd=0;   // data + sof marker in 9th bit
wire not_head = post_cnt==5;
reg badge_stb_r=0;
reg data_s_d=0;
wire trig = data_s & ~data_s_d;
always @(posedge clk) begin
	data_s_d <= data_s;
	// Setup counter to start writing the badge at the end of data
	// Stagnate counter at 5, and if that's the case write data through
	post_cnt <= data_f ? 3'd0 : not_head ? 3'd5 : post_cnt+1;
	if (trig) origin <= fp;
	case (post_cnt)
		// 12 unused bits, will find customers later, including authentication
		0: pxd <= {1'b1, 1'b0, 7'b0};
		1: pxd <= {1'b1, 1'b1, pack_len[6:0]};
		2: pxd <= {1'b0, 4'd0, pack_len[10:7]};
		3: pxd <= {1'b0, status_r};
		4: pxd <= {1'b0, 8'd0};
		5: pxd <= {1'b0, data_in};
		default: pxd <= 9'bx;
	endcase
	fp <= fp+1;
	fpp <= data_s ? fp + 5 : not_head ? fp : origin + post_cnt;
	badge_stb_r <= post_cnt!=0 && post_cnt!=5;
end

// Output ports
assign mem_a = fpp;
assign mem_d = pxd;
assign badge_stb = badge_stb_r;

// MAC logic
reg [10:0] mac_a0=0;
reg mac_bank=0, rx_mac_hbank_r=1;
wire bank_ready = mac_bank != rx_mac_hbank_r;
assign rx_mac_buf_status = {rx_mac_hbank_r, mac_bank};
reg mac_save=0, mac_stopping=0;
reg mac_queue=0;
always @(posedge clk) begin
	rx_mac_hbank_r <= rx_mac_hbank;  // Likely clock domain crossing
	if (trig & bank_ready) mac_save <= 1;
	if (trig) mac_a0 <= 4;
	else if (post_cnt==1) mac_a0 <= 0;
	else mac_a0 <= mac_a0 + 1;
	mac_stopping <= post_cnt == 4;
	if (mac_stopping) mac_save <= 0;
	if ((post_cnt==1) & mac_save & rx_mac_accept) begin
		// At his point we know we'll forward the packet to the host
		mac_queue <= 1;
	end
	if (mac_stopping & mac_queue) begin
		mac_bank <= ~mac_bank;
		mac_queue <= 0;
	end
end
assign rx_mac_d = pxd;
assign rx_mac_a = {mac_bank, mac_a0};
assign rx_mac_wen = mac_save;

// Convert to Gray code for Rx side, so Rx and Tx can be in different clock domains
wire [paw-1:0] fp_gray = fp ^ {1'b0, fp[paw-1:1]};
reg [paw-1:0] gray_state_r=0; always @(posedge clk) gray_state_r <= fp_gray;
assign gray_state = gray_state_r;

endmodule
// Content-addressable memory for UDP port numbers

// Checking for 8 x 16-bit UDP ports in parallel with synthesis-time
// configured port numbers would take roughly 49 LUT (32 for the comparisons,
// plus overhead).  Switching this to run-time configuration of port numbers
// ups that count to about 217 (192 just to hold the numbers and do the
// comparison, plus overhead).  That's almost half the size of the core
// rtefi_pipe without this feature.

// This version holds the port numbers in 16 x 8 RAM, and performs a
// walk-through of that memory in 16 cycles.  LUT count is about 32
// (for the case naw=3) including the distributed memory.

// The possible complication to this approach shows up with short packets.
// In a simple-minded tap simulation, a minimal length UDP packet
// (no data, 8 bytes long including the header) will require the answer
// approximately six cycles after the port number arrives, in order to
// get stored into MTU memory.  In real life, Ethernet packets have
// a minimum frame size of 64 bytes.  Thus the minimal UDP packet will
// necessarily be followed by 18 padding bytes (usually zero) before the
// CRC32.  That's plenty of time for this module to do its work.  Problems
// could only show up in such over-simplified simulations or if attached to
// standards-violating Ethernet hardware.  The simulation problem has been
// addressed by upgrading ethernet_model.c to add that padding.

// A true single-cycle CAM architecture (such as described in Xilinx
// XAPP1151) could give similar resource footprint, if carefully done,
// but with much less natural setup from the local bus.  A single
// port matcher would use two 32x1 RAMs, each taking 4 address bits from
// the data stream and 1 for high/low byte.

module udp_port_cam #(
	parameter naw=3  // address width for abstract port memory
) (
	input clk,
	input port_s,
	input [7:0] data,
	// port to config memory, single-cycle latency
	// 8-bit with naw+1 address bits, where an abstract
	// version would be 16-bit with naw address bits
	output [naw:0] pno_a,
	input [7:0] pno_d,
	// Results - a port pointer
	output [naw-1:0] port_p,
	output port_h,  // port_p is meaningful (hit)
	output port_v  // timing only: above two results are in
);

// Input setup
reg port_s_d=0;
reg [7:0] port_in1=0, port_in2=0;
reg [naw:0] port_cnt=0;
wire [naw:0] port_cnt_next = port_s ? 0 : port_cnt + 1;
wire port_load = port_s | port_s_d;
always @(posedge clk) begin
	port_s_d <= port_s;
	port_in1 <= port_load ? data : port_in2;
	port_in2 <= port_in1;
	port_cnt <= port_cnt_next;
end
assign pno_a = port_cnt_next;

// Central comparison
wire equal = port_in1 == pno_d;

// Find out when both upper and lower bytes match
reg eq_hold=0;
reg [naw-1:0] port_p_r=0;
reg port_v_r=0, port_h_r=0;
always @(posedge clk) begin
	eq_hold <= equal;
	if (equal & eq_hold & port_cnt[0] & ~port_v_r) begin
		port_h_r <= 1;
		port_p_r <= port_cnt[naw:1];
	end
	if (&port_cnt) port_v_r <= 1;
	if (port_s) begin
		port_h_r <= 0;
		port_v_r <= 0;
	end
end
assign port_p = port_p_r;
assign port_h = port_h_r;
assign port_v = port_v_r;

endmodule
// Hacked to support Ethernet
module crc8e_guts(
	input clk,
	input gate,
	input first,  // set this during the first clock cycle of a new block of data
	input [7:0] d_in,
	output [7:0] d_out,
	output zero
);
// http://en.wikipedia.org/wiki/Cyclic_redundancy_check
parameter wid=32;
parameter init=32'hffffffff;

// Three names are magic to crc_guts.vh:
//   D    data in
//   O    old CRC value
//   crc  new CRC value
reg [wid-1:0] crc=0;
wire [7:0] D = d_in;
wire [wid-1:0] O = first ? init : crc;
always @(posedge clk) if (gate) begin
// Machine generated by ./crc_derive -lsb 32 0x4c11db7 8
// D is the 8-bit input data (lsb-first)
// crc and O are the new and old 32-bit CRC
// Generating polynomial is 0x4c11db7 (normal form, leading 1 suppressed)
// Reference: https://en.wikipedia.org/wiki/Cyclic_redundancy_check
crc[0] <= D[7]^D[1]^O[24]^O[30];
crc[1] <= D[7]^D[6]^D[1]^D[0]^O[24]^O[25]^O[30]^O[31];
crc[2] <= D[7]^D[6]^D[5]^D[1]^D[0]^O[24]^O[25]^O[26]^O[30]^O[31];
crc[3] <= D[6]^D[5]^D[4]^D[0]^O[25]^O[26]^O[27]^O[31];
crc[4] <= D[7]^D[5]^D[4]^D[3]^D[1]^O[24]^O[26]^O[27]^O[28]^O[30];
crc[5] <= D[7]^D[6]^D[4]^D[3]^D[2]^D[1]^D[0]^O[24]^O[25]^O[27]^O[28]^O[29]^O[30]^O[31];
crc[6] <= D[6]^D[5]^D[3]^D[2]^D[1]^D[0]^O[25]^O[26]^O[28]^O[29]^O[30]^O[31];
crc[7] <= D[7]^D[5]^D[4]^D[2]^D[0]^O[24]^O[26]^O[27]^O[29]^O[31];
crc[8] <= D[7]^O[0]^D[6]^D[4]^D[3]^O[24]^O[25]^O[27]^O[28];
crc[9] <= D[6]^O[1]^D[5]^D[3]^D[2]^O[25]^O[26]^O[28]^O[29];
crc[10] <= D[7]^D[5]^O[2]^D[4]^D[2]^O[24]^O[26]^O[27]^O[29];
crc[11] <= D[7]^D[6]^D[4]^O[3]^D[3]^O[24]^O[25]^O[27]^O[28];
crc[12] <= D[7]^D[6]^D[5]^D[3]^O[4]^D[2]^D[1]^O[24]^O[25]^O[26]^O[28]^O[29]^O[30];
crc[13] <= D[6]^D[5]^D[4]^D[2]^O[5]^D[1]^D[0]^O[25]^O[26]^O[27]^O[29]^O[30]^O[31];
crc[14] <= D[5]^D[4]^D[3]^D[1]^O[6]^D[0]^O[26]^O[27]^O[28]^O[30]^O[31];
crc[15] <= D[4]^D[3]^D[2]^D[0]^O[7]^O[27]^O[28]^O[29]^O[31];
crc[16] <= D[7]^D[3]^D[2]^O[8]^O[24]^O[28]^O[29];
crc[17] <= D[6]^D[2]^D[1]^O[9]^O[25]^O[29]^O[30];
crc[18] <= D[5]^D[1]^D[0]^O[10]^O[26]^O[30]^O[31];
crc[19] <= D[4]^D[0]^O[11]^O[27]^O[31];
crc[20] <= D[3]^O[12]^O[28];
crc[21] <= D[2]^O[13]^O[29];
crc[22] <= D[7]^O[14]^O[24];
crc[23] <= D[7]^D[6]^D[1]^O[15]^O[24]^O[25]^O[30];
crc[24] <= D[6]^D[5]^D[0]^O[16]^O[25]^O[26]^O[31];
crc[25] <= D[5]^D[4]^O[17]^O[26]^O[27];
crc[26] <= D[7]^D[4]^D[3]^D[1]^O[18]^O[24]^O[27]^O[28]^O[30];
crc[27] <= D[6]^D[3]^D[2]^D[0]^O[19]^O[25]^O[28]^O[29]^O[31];
crc[28] <= D[5]^D[2]^D[1]^O[20]^O[26]^O[29]^O[30];
crc[29] <= D[4]^D[1]^D[0]^O[21]^O[27]^O[30]^O[31];
crc[30] <= D[3]^D[0]^O[22]^O[28]^O[31];
crc[31] <= D[2]^O[23]^O[29];
end
wire [7:0] dr = ~crc[wid-1:wid-8]; // note polarity inversion
assign d_out = {dr[0],dr[1],dr[2],dr[3],dr[4],dr[5],dr[6],dr[7]};
// note bit order reversal

// assign zero = ~(|crc);
assign zero = crc==32'hc704dd7b;
endmodule
// Output packet construction

// Handles Ethernet, ARP, and IP layers, ready to hand over
// to the application-layer UDP content handling.
// The core of the data path is documented in doc/tx_path.eps,
// with the table generated by tx_gen.py based on
// tx_*_table.csv.

// Synthesized on its own, without the associated packet memory
// or MAC/IP config memory, it takes up about 74 LUTs.

module construct #(
	parameter paw=11,  // packet address width, 11 IRL, maybe less for simulations
	parameter p_offset = 480  // Keep an eye on this.
	// Has to be at least 6 for usual fp_offset of 0, but also
	// add -min(fp_offset)+guard.  The guard needs to include
	// allowance Rx/Tx frequency offset.
	// At the other end, p_offset + max(fp_offset) < (2048-MTU-guard)
) (
	input clk,
	input [paw-1:0] gray_state,
	// port to MAC/IP config, single-cycle latency
	output [3:0] ip_a,
	input [7:0] ip_d,
	// Read port of 1 MTU DPRAM, again single-cycle latency
	output [paw-1:0] addr,
	input [8:0] pbuf_out,
	// Debugging hook
	output badge_stb,
	output [7:0] badge_data,
	output xdomain_fault,
	output xcheck_fault,
	// Output to xformer
	output [5:0] pc,
	output [1:0] category,
	output [2:0] udp_sel,
	output [7:0] eth_data_out,
	output eth_strobe_long,  // includes GMII preamble and CRC32
	output eth_strobe_short  // doesn't
);

// Capture state across clock domains, convert back to binary
reg [paw-1:0] gray_l=0, state=0;
// verilator lint_off UNOPTFLAT
wire [paw-1:0] new_state = gray_l ^ {1'b0, new_state[paw-1:1]};
// verilator lint_on UNOPTFLAT
always @(posedge clk) begin
	gray_l <= gray_state;
	state <= new_state;
end

// Debugging hook
reg [paw-1:0] old_state=0, state_diff=0;
reg xdomain_fault_r=0;
always @(posedge clk) begin
	old_state <= state;
	state_diff <= state - old_state;
	// state_diff must be 0, 1, or 2 for things to work right
	xdomain_fault_r <= |state_diff[paw-1:2] || &state_diff[1:0];
end
assign xdomain_fault = xdomain_fault_r;


// Construct frame pointer that tracks the one in scanner.v
wire packet_active;
wire [paw-1:0] fp;



// cope with max 100 ppm frequency offset between input and output.
reg [paw-1:0] fp_r=0;
assign fp = packet_active ? fp_r+1 : state+p_offset;
always @(posedge clk) fp_r <= fp;
// This will be really slow.  Have to pack an increment, mux, add,
// and RAM access into a single cycle.

// XXX Deserves a consistency check to find out if fp drifts into
// a danger zone relative to state.

reg [5:0] pc_r=0;
// SOF: Start Of Frame
wire pre_sof = pbuf_out[8] & ~pbuf_out[7] && (pc_r==0);
wire sof = pbuf_out[8] & pbuf_out[7] && (pc_r==0);  // hack to get around x's in fp_offset
wire [7:0] pbuf_out8 = pbuf_out[7:0];
wire signed [5:0] fp_offset, cf_offset;
reg live=0;
assign packet_active = pre_sof | sof | live;
reg [10:0] pack_len_r=0;
wire pc_not_saturated = |(~pc_r[5:4]);  // check if pc < 48
wire [5:0] next_pc = sof ? 2 : live ? pc_r + pc_not_saturated : 0;

// reference: status_vec = {port_p, pass_ip, pass_ethmac, crc_zero, category};
reg [7:0] status_vec=0;
assign category = status_vec[1:0];
assign udp_sel = status_vec[7:5];
reg p_strobe=0;  // Reading packet content (including checksum)
reg o_strobe=0;  // ignores checksum
reg sof_d=0;
// Would it take fewer resources to replace sof_d with (live && pc_r == 2)?
// Or to replace (live && pc_r==3) with sof_dd?  Need to measure to find out.
// Could be worth breaking this up into 2 always blocks (badge and data)?
// Not really, they both have to touch the "live" register.
always @(posedge clk) begin
	pc_r <= next_pc;
	sof_d <= sof;
	if (sof) begin
		live <= 1;
		pack_len_r[6:0] <= pbuf_out8[6:0];
	end
	if (sof_d) pack_len_r[10:7] <= pbuf_out8[3:0];
	if (live && pc_r==3) status_vec <= pbuf_out8;
	// pc_r == 5 the badge has been read!
	if (live && pc_r==5 && category!=0) begin o_strobe <= 1; p_strobe <= 1; end
	if (live && pc_r==5 && category==0) begin live <= 0; pack_len_r <= 0; end
	if (p_strobe) pack_len_r <= pack_len_r-1;
	if (pack_len_r==5) o_strobe <= 0;
	if (pack_len_r==1) begin p_strobe <= 0; live <= 0; end
end

// Debug
reg [2:0] sof_chain=0;
always @(posedge clk) sof_chain <= {sof_chain[1:0], sof};
assign badge_stb = sof | (|sof_chain);
assign badge_data = pbuf_out8;

// Look up instruction and start using it
wire [1:0] out, chk_in;
wire [7:0] template;
construct_tx_table prog(.a({category, pc_r}),
	.v({out, fp_offset, cf_offset, chk_in, template}));
assign addr = fp + {{5{fp_offset[5]}}, fp_offset};
assign ip_a = pc_r + cf_offset;

// Align cycles with the one-cycle delay going through RAM
// (a bit wasteful, could mess with table generation instead?)
// Pipelining not shown in doc/tx_path.eps
reg [7:0] template_d=0;
reg [1:0] out_d=0, chk_in_d=0;
always @(posedge clk) begin
	template_d <= template;
	out_d <= out;
	chk_in_d <= chk_in;
end

// Multiplexers, need to stay consistent with tx_gen.py
reg [7:0] d_chk=0;
always @(posedge clk) case (chk_in_d)
	2'b00: d_chk <= pbuf_out8;
	2'b01: d_chk <= ip_d;
	2'b10: d_chk <= template_d;
	2'b11: d_chk <= 8'd0;
endcase
wire [7:0] ip_head_chksum_data;
// IP header checksum calculation
reg chksum_zero=0, chksum_gate=0;
always @(posedge clk) begin
	chksum_zero <= pc_r <= 3;
	chksum_gate <= (chk_in_d != 2'b11) & ~chksum_zero;
end
ones_chksum ck(.clk(clk), .clear(chksum_zero), .gate(chksum_gate),
	.din(d_chk), .sum(ip_head_chksum_data));

reg [7:0] d_out_pre=0;
always @(posedge clk) case (out_d)
	2'b00: d_out_pre <= pbuf_out8;
	2'b01: d_out_pre <= ip_d;
	2'b10: d_out_pre <= template_d;
	2'b11: d_out_pre <= 0;
endcase
// Last-minute insertion of IP header checksum result .. haha minute
reg out_d_chk_sub=0;
always @(posedge clk) out_d_chk_sub <= out_d == 2'b11;
wire [7:0] d_out = out_d_chk_sub ? ip_head_chksum_data : d_out_pre;
// This could create a critical speed path

// Close out timing within this module
reg [7:0] eth_data_out_r=0;   always @(posedge clk) eth_data_out_r <= d_out;
reg eth_strobe_short_r=0;     always @(posedge clk) eth_strobe_short_r <= o_strobe;
reg pack_len_nz=0;     always @(posedge clk) pack_len_nz <= pack_len_r != 0;
reg [5:0] pc_d=0;      always @(posedge clk) pc_d <= pc_r;

assign eth_data_out = eth_data_out_r;
assign eth_strobe_short = eth_strobe_short_r;
assign eth_strobe_long = pack_len_nz && pc_r > 3 && category != 0;
assign pc = pc_d;

// Debug only, will be dropped if you don't hook up the xcheck_fault port:
// Cross-check the IP header checksum we just computed
reg xcheck_zero=0, xcheck_gate=0, xcheck_ones_d=0;
reg xcheck_capture=0, xcheck_fault_r=0;
wire xcheck_ones;
always @(posedge clk) begin
	xcheck_zero <= pc_r <= 4;
	xcheck_gate <= pc_r >= 20 && pc_r < 40;
	xcheck_ones_d <= xcheck_ones;
	xcheck_capture <= pc_r == 40;
	xcheck_fault_r <= xcheck_capture & ~xcheck_ones & ~xcheck_ones_d;
end
ones_chksum xchk(.clk(clk), .clear(xcheck_zero), .gate(xcheck_gate),
	.din(eth_data_out), .all_ones(xcheck_ones));
assign xcheck_fault = xcheck_fault_r;

endmodule
// Table lookup controlling output packet data path
// Machine-generated by tx_gen.py
// v = {out, fp_offset, cf_offset, chk_in, template};
module construct_tx_table(
    input [7:0] a,
    output [23:0] v
);
reg [23:0] r;  // really combinational
always @(*) case (a)
       0: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
       1: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
       2: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
       3: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
       4: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
       5: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
       6: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
       7: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
       8: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
       9: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      10: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      11: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      12: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      13: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      14: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      15: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      16: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      17: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      18: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      19: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      20: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      21: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      22: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      23: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      24: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      25: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      26: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      27: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      28: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      29: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      30: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      31: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      32: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      33: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      34: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      35: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      36: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      37: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      38: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      39: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      40: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      41: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      42: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      43: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      44: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      45: r = 24'bxx_xxxxxx_xxxxxx_xx_xxxxxxxx;
      64: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
      65: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
      66: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
      67: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
      68: r = 24'b00_000110_xxxxxx_xx_xxxxxxxx;
      69: r = 24'b00_000110_xxxxxx_xx_xxxxxxxx;
      70: r = 24'b00_000110_xxxxxx_xx_xxxxxxxx;
      71: r = 24'b00_000110_xxxxxx_xx_xxxxxxxx;
      72: r = 24'b00_000110_xxxxxx_xx_xxxxxxxx;
      73: r = 24'b00_000110_xxxxxx_xx_xxxxxxxx;
      74: r = 24'b01_xxxxxx_110110_xx_xxxxxxxx;
      75: r = 24'b01_xxxxxx_110110_xx_xxxxxxxx;
      76: r = 24'b01_xxxxxx_110110_xx_xxxxxxxx;
      77: r = 24'b01_xxxxxx_110110_xx_xxxxxxxx;
      78: r = 24'b01_xxxxxx_110110_xx_xxxxxxxx;
      79: r = 24'b01_xxxxxx_110110_xx_xxxxxxxx;
      80: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
      81: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
      82: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
      83: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
      84: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
      85: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
      86: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
      87: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
      88: r = 24'b10_xxxxxx_xxxxxx_xx_00000000;
      89: r = 24'b10_xxxxxx_xxxxxx_xx_00000010;
      90: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      91: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      92: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      93: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      94: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      95: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      96: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      97: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      98: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
      99: r = 24'b01_xxxxxx_100110_xx_xxxxxxxx;
     100: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     101: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     102: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     103: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     104: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     105: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     106: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     107: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     108: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     109: r = 24'b00_110110_xxxxxx_xx_xxxxxxxx;
     128: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
     129: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
     130: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
     131: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
     132: r = 24'b00_000110_000010_01_xxxxxxxx;
     133: r = 24'b00_000110_000010_01_xxxxxxxx;
     134: r = 24'b00_000110_000010_01_xxxxxxxx;
     135: r = 24'b00_000110_000010_01_xxxxxxxx;
     136: r = 24'b00_000110_xxxxxx_11_xxxxxxxx;
     137: r = 24'b00_000110_xxxxxx_11_xxxxxxxx;
     138: r = 24'b01_010100_110110_00_xxxxxxxx;
     139: r = 24'b01_010100_110110_00_xxxxxxxx;
     140: r = 24'b01_010100_110110_00_xxxxxxxx;
     141: r = 24'b01_010100_110110_00_xxxxxxxx;
     142: r = 24'b01_xxxxxx_110110_11_xxxxxxxx;
     143: r = 24'b01_xxxxxx_110110_11_xxxxxxxx;
     144: r = 24'b00_000000_xxxxxx_11_xxxxxxxx;
     145: r = 24'b00_000000_xxxxxx_11_xxxxxxxx;
     146: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     147: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     148: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     149: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     150: r = 24'b10_xxxxxx_xxxxxx_10_00000000;
     151: r = 24'b10_xxxxxx_xxxxxx_10_00000000;
     152: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     153: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     154: r = 24'b10_xxxxxx_xxxxxx_10_00100000;
     155: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     156: r = 24'b11_xxxxxx_xxxxxx_10_00000000;
     157: r = 24'b11_xxxxxx_xxxxxx_10_00000000;
     158: r = 24'b01_xxxxxx_101000_xx_xxxxxxxx;
     159: r = 24'b01_xxxxxx_101000_xx_xxxxxxxx;
     160: r = 24'b01_xxxxxx_101000_xx_xxxxxxxx;
     161: r = 24'b01_xxxxxx_101000_xx_xxxxxxxx;
     162: r = 24'b00_111100_xxxxxx_xx_xxxxxxxx;
     163: r = 24'b00_111100_xxxxxx_xx_xxxxxxxx;
     164: r = 24'b00_111100_xxxxxx_xx_xxxxxxxx;
     165: r = 24'b00_111100_xxxxxx_xx_xxxxxxxx;
     166: r = 24'b10_000000_xxxxxx_xx_00000000;
     167: r = 24'b10_000000_xxxxxx_xx_00000000;
     168: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     169: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     170: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     171: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     172: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     173: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     192: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
     193: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
     194: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
     195: r = 24'bxx_000000_xxxxxx_xx_xxxxxxxx;
     196: r = 24'b00_000110_000010_01_xxxxxxxx;
     197: r = 24'b00_000110_000010_01_xxxxxxxx;
     198: r = 24'b00_000110_000010_01_xxxxxxxx;
     199: r = 24'b00_000110_000010_01_xxxxxxxx;
     200: r = 24'b00_000110_xxxxxx_11_xxxxxxxx;
     201: r = 24'b00_000110_xxxxxx_11_xxxxxxxx;
     202: r = 24'b01_010100_110110_00_xxxxxxxx;
     203: r = 24'b01_010100_110110_00_xxxxxxxx;
     204: r = 24'b01_010100_110110_00_xxxxxxxx;
     205: r = 24'b01_010100_110110_00_xxxxxxxx;
     206: r = 24'b01_xxxxxx_110110_11_xxxxxxxx;
     207: r = 24'b01_xxxxxx_110110_11_xxxxxxxx;
     208: r = 24'b00_000000_xxxxxx_11_xxxxxxxx;
     209: r = 24'b00_000000_xxxxxx_11_xxxxxxxx;
     210: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     211: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     212: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     213: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     214: r = 24'b10_xxxxxx_xxxxxx_10_00000000;
     215: r = 24'b10_xxxxxx_xxxxxx_10_00000000;
     216: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     217: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     218: r = 24'b10_xxxxxx_xxxxxx_10_00100000;
     219: r = 24'b00_000000_xxxxxx_00_xxxxxxxx;
     220: r = 24'b11_xxxxxx_xxxxxx_10_00000000;
     221: r = 24'b11_xxxxxx_xxxxxx_10_00000000;
     222: r = 24'b01_xxxxxx_101000_xx_xxxxxxxx;
     223: r = 24'b01_xxxxxx_101000_xx_xxxxxxxx;
     224: r = 24'b01_xxxxxx_101000_xx_xxxxxxxx;
     225: r = 24'b01_xxxxxx_101000_xx_xxxxxxxx;
     226: r = 24'b00_111100_xxxxxx_xx_xxxxxxxx;
     227: r = 24'b00_111100_xxxxxx_xx_xxxxxxxx;
     228: r = 24'b00_111100_xxxxxx_xx_xxxxxxxx;
     229: r = 24'b00_111100_xxxxxx_xx_xxxxxxxx;
     230: r = 24'b00_000010_xxxxxx_xx_xxxxxxxx;
     231: r = 24'b00_000010_xxxxxx_xx_xxxxxxxx;
     232: r = 24'b00_111110_xxxxxx_xx_xxxxxxxx;
     233: r = 24'b00_111110_xxxxxx_xx_xxxxxxxx;
     234: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     235: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     236: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
     237: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
 default: r = 24'b00_000000_xxxxxx_xx_xxxxxxxx;
endcase
assign v = r;
endmodule
// 16-bit ones-complement checksum calculator
// Applies to all of IP header, ICMP, and UDP checksums
// Well, difficult to use with UDP because of its pathological
// inclusion of _two_ copies of the UDP length.
// mostly cribbed from core/assemble_eth.v

module ones_chksum(
	input clk,
	input clear,
	input gate,
	input [7:0] din,
	output [7:0] sum,
	output all_ones
);

reg [7:0] chksum=0, chksum1=0;
reg chksum_carry=0;
always @(posedge clk) begin
	if (clear) {chksum_carry, chksum} <= 9'h0;
	else if (gate) {chksum_carry, chksum} <=
		chksum1 + din + chksum_carry;
	if (clear) chksum1 <= 8'h0;
	else if (gate) chksum1 <= chksum;
end
assign sum = ~(chksum1 + chksum_carry);
assign all_ones = &chksum;

endmodule
// Transitional/transformational module
// Uses the rearranged input packet and meta-information
// to create output packet, still sans CRC32.
module xformer(
	input clk,
	input [5:0] pc,
	input [1:0] category,
	input [2:0] udp_sel,
	input [7:0] idata,
	input eth_strobe_short,
	input eth_strobe_long,
	// As documented in doc/clients.eps
	output [10:0] len_c,
	// don't bother with data output port, it's the same as idata above
	// 7 of these strobes for the 7 possible clients
	output [6:0] raw_l,
	output [6:0] raw_s,
	// mass input from 7 possible clients
	input [7*8-1:0] mux_data_in,
	//
	output [7:0] odata,
	output ostrobe_s,
	output ostrobe_l
);

// Configuration
parameter n_lat=2;
parameter handle_icmp = 1;

wire icmp = (category == 2) & handle_icmp;
wire udp = category == 3;

// ICMP Echo Checksum (see RFC 792 p. 13)
// For causality reasons, can only be hacked based on
// assuming the input checksum was valid.
// This was the approach taken by Du in icmp_rx.v.
wire [7:0] d_out2;
// Desired pc cycle is 41 in the frame of tx_ip_table.txt,
// but we've accumulated two cycles of pipeline delay.
reg icmp_kick=0; always @(posedge clk) icmp_kick <= icmp & (pc==42);
wire [7:0] odata0;
// Always instantiate this; it turns into a simple pass-through
// (two cycles delayed) when not kicked.
hack_icmp_cksum hack_icmp_cksum(.clk(clk),
	.kick(icmp_kick), .idat(idata), .odat(odata0));

// Delay strobe to match 2-cycle delay in hack_icmp_chksum; refactor?
reg o_strobe1=0, o_strobe2=0;
reg l_strobe1=0, l_strobe2=0;
always @(posedge clk) begin
	o_strobe1 <= eth_strobe_short;
	o_strobe2 <= o_strobe1;
	l_strobe1 <= eth_strobe_long;
	l_strobe2 <= l_strobe1 && category != 0;
end

// Timing
// It's OK to pass-through the UDP checksum when udp_sel==0, because
// nothing has changed from Rx packet except the order of IP addresses
// and port numbers, and the checksum process is not sensitive to the
// order of 16-bit words.  For all other UDP packets, we have to disable
// the checksum by replacing it with zero.  See below.
reg pc_at_checksum=0;
reg use_zero=0, use_copy=0;
always @(posedge clk) begin
	use_copy <= ~udp || pc < 48 || udp_sel == 0;
	pc_at_checksum <= pc == 46 || pc == 47;
	use_zero <= udp && (udp_sel != 0) && pc_at_checksum;
end

// UDP length down-counter
reg [10:0] pdata_count=0;
reg [3:0] len_stb=0;
wire len_soon = pc==43 && udp;
reg pdata_down=0;
always @(posedge clk) begin
	len_stb <= {len_stb[2:0], len_soon};
	if (len_stb[0]) pdata_count[10:8] <= idata;
	if (len_stb[1]) pdata_count[7:0] <= idata;
	// a zero-length UDP packet must never assert data-valid
	if (len_stb[3] && pdata_count > 8) pdata_down <= 1;
	if (pdata_down) pdata_count <= pdata_count - 1;
	if (pdata_count == 9) pdata_down <= 0;
end

// Signals documented in doc/clients.eps
// Fan out the strobes based on udp_sel
wire [7:0] mask = 1 << udp_sel;
assign len_c = pdata_count;
assign raw_l = mask[7:1] & {7{eth_strobe_long}};
assign raw_s = mask[7:1] & {7{pdata_down}};

// Pipeline alignment
// Names are horrid
wire [11:0] pipe_in = {o_strobe2, l_strobe2, use_zero, use_copy, odata0};
wire use_zero1, use_copy1;  wire [7:0] odata1;
reg_delay #(.len(n_lat-2), .dw(12)) pipe(.clk(clk), .gate(1'b1), .reset(1'b0),
	.din(pipe_in),
	.dout({ostrobe_s, ostrobe_l, use_zero1, use_copy1, odata1}));

// Multiplexer
// Suppress UDP checksum for causality reasons; if there's a client
// that wants to fake it, we would need to give it an option to set
// the checksum to some non-zero (but still constant) value here.
reg [7:0] odatax;
wire [8*8-1:0] mux_data_in2 = {mux_data_in, odata1};
always @(*) begin
	if (use_zero1) odatax = 0;  // UDP checksum
	else if (use_copy1) odatax = odata1;
	else odatax = mux_data_in2[8*udp_sel +: 8];
end
assign odata = odatax;

endmodule
// Appends 32-bit Ethernet CRC to the end of a packet
// Also inserts GMII preamble
//
// The cycle-by-cycle timing definition for these tasks
// comes from the raw_s (short) and raw_l (long) strobes;
// raw_s is valid just for the (incoming) packet data.
// raw_l is also valid for a few cycles before, and 4 cycles after, that.
module ethernet_crc_add(
	input clk,
	input raw_s,
	input raw_l,
	input [7:0] raw_d,
	output opack_s,
	output [7:0] opack_d
);

// Strobes are easy
reg raw_s_d=0, raw_l_d=0;
always @(posedge clk) begin
	raw_s_d <= raw_s;
	raw_l_d <= raw_l;
end
wire first_crc = raw_s & ~raw_s_d;
wire trail = raw_s_d & ~raw_s;
wire gate_crc;
wire out_crc_sel;

// Instantiation
wire [7:0] crc_out;
crc8e_guts #(.wid(32)) crc8e(.clk(clk), .gate(gate_crc),
	.first(first_crc), .d_in(out_crc_sel ? ~crc_out : raw_d),
	.d_out(crc_out), .zero());

// Multiplexing
reg [1:0] crc_cnt=0;
reg [7:0] opack_r=0;
assign gate_crc = raw_s | raw_s_d | (crc_cnt != 0);
assign out_crc_sel = trail | (|crc_cnt);
always @(posedge clk) begin
	crc_cnt <= out_crc_sel ? crc_cnt+1 : 0;
	opack_r <= out_crc_sel ? crc_out : raw_s ? raw_d : 8'h55;
end
assign opack_d = first_crc ? 8'hd5 : opack_r;
assign opack_s = raw_l | raw_l_d;

endmodule
// Subtracts 0x800 from an ICMP checksum
// Sounds easy, right?  But actually pretty tricky to correctly
// handle 16-bit one's-complement arithmetic on data flying by 8-bits
// at a time.  Tricky enough that Du got it wrong in icmp_rx.v;
// that code gets the right checksum only 31/32 of the time.
// Quoting RFC 792:
//    The checksum is the 16-bit ones's [sic] complement of the one's
//    complement sum of the ICMP message starting with the ICMP Type.

// Output is delayed two cycles from input.
// kick needs to be asserted on the second of the two cycles
//   with the checksum at the input.

module hack_icmp_cksum(
	input clk,
	input kick,
	input [7:0] idat,
	output [7:0] odat
);

// Precompute the all-ones condition
wire ones_i = &idat;
reg ones_r=0;
always @(posedge clk) ones_r <= ones_i;
wire all_ones = ones_i & ones_r;

// Insert modified checksum into stream
wire [15:0] x3;
reg [7:0] dat1=0, dat2=0;
always @(posedge clk) begin
	dat1 <= kick ? x3[7:0] : idat;
	dat2 <= kick ? x3[15:8] : dat1;
end

// 16-bit checksum arithmetic
// Because of the extra inversion, we really add 0x800.
wire [15:0] x0 = {dat1, idat};
wire [15:0] x1 = {x0[10:0], x0[15:11]};  // rotate right 11 bits
wire [15:0] x2 = x1 + 1 + all_ones;
assign x3 = {x2[4:0], x2[15:5]};  // rotate left 11 bits

assign odat = dat2;

endmodule
`timescale 1ns / 1ns

// Encapsulation of a register delay, z^{-n} in DSP-speak
// Properly handles odd-ball special cases like len==0
module reg_delay #(
	parameter dw=16,  // Width of data
	parameter len=4   // Cycles to delay
) (
	input clk,  // Rising edge clock input; all logic is synchronous in this domain
	input reset,  // Please tie to 0 if you can; see below
	input gate,  // Enable processing
	input [dw-1:0] din,  // Input data
	output [dw-1:0] dout  // Output data
);

// When used in a Xilinx chip, ideally this logic is turned into
// a bunch of SRL16 shift registers or similar.  That works only if
// our reset port is tied to 1'b0 at instantiation site.
generate if (len > 1) begin: usual
	reg [dw*len-1:0] shifter=0;
	always @(posedge clk) begin
		if (gate) shifter <= {shifter[dw*len-1-dw:0],din};
		if (reset) shifter <= 0;
	end
	assign dout = shifter[dw*len-1:dw*len-dw];
end else if (len > 0) begin: degen1
	reg [dw*len-1:0] shifter=0;
	always @(posedge clk) begin
		if (gate) shifter <= din;
		if (reset) shifter <= 0;
	end
	assign dout = shifter[dw*len-1:dw*len-dw];
end else if (len == 0) begin: degen0
	assign dout = din;
end else begin: bad
	assign dout = din[-1:0];
end
endgenerate

endmodule
module mac_subset #(
	parameter mac_aw=10,  // 16-bit words
	parameter big_endian=0,
	parameter latency=256,
	parameter stretch=4,  // minimum value 2, should be 4 for GMII
	parameter ifg=24   // must have more padding than just Ethernet IFG
) (
	// connect the 2 below to an external 16 bit dual port ram
	output [mac_aw - 1: 0] host_raddr,
	input [15:0] host_rdata,
	// address where we should start transmitting from
	input [mac_aw - 1: 0] buf_start_addr,
	// set start to trigger transmit, wait for done, reset start
	input tx_mac_start,
	output tx_mac_done,
	// crucial information from input scanner
	input scanner_busy,
	// Connection to output multiplexer, right after xformer.v,
	// data path will get routed to have CRC added, strobes are
	// as needed by that step: strobe_s includes data only,
	// strobe l includes time slots for GMII preamble and CRC.
	input tx_clk,
	output strobe_s,
	output strobe_l,
	output [7:0] mac_data
);

reg host_start_=0;
always @(posedge tx_clk) begin
	host_start_ <= tx_mac_start;
end

// Instantiate MAC
wire req;
wire [10:0] len_req;
wire mac_strobe;
test_tx_mac #(
	.mac_aw(mac_aw)
) mac(
	.clk(tx_clk),
	.host_addr(host_raddr),
	.host_d(host_rdata),
	.start(host_start_),
	.buf_start_addr(buf_start_addr),
	.done(tx_mac_done),
	.req(req),
	.len_req(len_req),
	.strobe(mac_strobe),
	.mac_data(mac_data)
);

// Instantiate precog
wire clear_to_send;
wire [10:0] precog_width = len_req + 2*ifg;
precog #(
	.PAW (11),
	.LATENCY (latency+ifg)
) precog (
	.clk (tx_clk),
	.tx_packet_width  (precog_width),
	.scanner_busy     (scanner_busy),
	.request_to_send  (req),
	.clear_to_send    (clear_to_send)
);

// Manipulate simple strobe from precog
// final system wants 4 cycles lead (for GMII preamble) and
// 4 cycle trailer (for CRC) on strobe_l compared to strobe_s.
// TODO this should be moved to precog
reg [stretch-1:0] strobe_sr1=0;
always @(posedge tx_clk) strobe_sr1 <= {strobe_sr1[stretch-2:0], clear_to_send};
reg [stretch-1:0] strobe_sr2=0;
always @(posedge tx_clk) strobe_sr2 <= {strobe_sr2[stretch-2:0], req};
assign mac_strobe = strobe_sr1[stretch-1] & req;
assign strobe_s = mac_strobe;
assign strobe_l = clear_to_send & strobe_sr2[stretch-1];

endmodule
// A gap detector for timing transmissions from the MAC.
// The `scanner` module looks ahead for a suitable gap in the packet badger
// data stream. Once found it indicates to the MAC, downstream of the
// ring-buffer, that its TX - packet can now be multiplexed onto the stream.

module precog #(
	// packet address width, 11 IRL
	parameter PAW=11,
	// latency from beginning of detected gap to `clear_to_send` going high
	parameter LATENCY=11
) (
	input clk,
	// during a gap of N cycles, `scanner_busy` goes low for N cycles
	input scanner_busy,
	// Minimum width of the gap. tx_packet_width must be <= LATENCY - 2
	input [PAW-1:0] tx_packet_width,
	// pulse to latch `tx_packet_width` and start searching for a gap
	input request_to_send,
	// Rising edge: `LATENCY` cycles after the beginning of the detected gap
	// Falling edge: `tx_packet_width` cycles after the rising edge
	output reg clear_to_send
);

initial clear_to_send = 0;
reg [PAW-1:0] gap_width = 0;
reg [PAW-1:0] tx_packet_width_l = 0;
reg [   11:0] delay_cnt = 0;
reg [    1:0] state = 0;
wire is_gap = gap_width >= tx_packet_width_l;
localparam ST_WAIT_RTS = 0;
localparam ST_WAIT_GAP = 1;
localparam ST_WAIT_RISING = 2;
localparam ST_WAIT_FALLING = 3;

always @(posedge clk) begin
	clear_to_send <= 0;
	if (gap_width < 2^PAW - 1)
		gap_width <= scanner_busy ? 0 : gap_width + 1;
	case (state)
		ST_WAIT_RTS: begin
			tx_packet_width_l <= tx_packet_width;
			if (request_to_send)
				state <= ST_WAIT_GAP;
		end

		ST_WAIT_GAP: begin
			delay_cnt <= 0;
			if (is_gap)
				state <= ST_WAIT_RISING;
		end

		ST_WAIT_RISING: begin
			delay_cnt <= delay_cnt + 1;
			if (delay_cnt >= LATENCY - tx_packet_width_l - 2) begin
				delay_cnt <= 0;
				clear_to_send <= 1;
				state <= ST_WAIT_FALLING;
			end
		end

		ST_WAIT_FALLING: begin
			delay_cnt <= delay_cnt + 1;
			if (delay_cnt >= tx_packet_width_l - 1)
				state <= ST_WAIT_RTS;
			else
				clear_to_send <= 1;
		end

		default: begin
			state <= ST_WAIT_RTS;
			gap_width <= 0;
			delay_cnt <= 0;
		end
	endcase
end

endmodule
module test_tx_mac #(
	parameter mac_aw=10,  // 16-bit words
	parameter big_endian=0
) (
	input clk,
	// There is an implied DPRAM _not_ included in this module.
	// These ports access its read port, with assumed 1-cycle latency
	// The packet length is stored as the first word of a buffer.
	// Endian-ness is configurable.
	output [mac_aw-1:0] host_addr,
	input [15:0] host_d,
	// Request from host to transmit a packet, already converted to
	// (or at least usable in) our clk domain.
	// OK to just latch buf_start_addr on one host clock cycle,
	// and raise the start signal on the next.
	// Also OK to construct buf_start_addr with a handful of
	// static 0 at the lsb (representing granularity of buffer starts),
	// could save a few registers in that clock domain crossing.
	input start,
	input [mac_aw-1:0] buf_start_addr,
	output done,  // 4-phase handshake with start signal
	// Connection to precog module
	output req,
	output [10:0] len_req,  // can represent 1 MTU, in octets
	// Connection to output multiplexer (xformer.v)
	input strobe,
	output [7:0] mac_data
);

reg [mac_aw-1:0] buffer_point;  // in words
reg [2:0] mode=0;
reg [10:0] len_req_r=0;
reg req_r=0, done_r=0;
reg odd_octet=0;
wire even_octet = ~odd_octet;
// There's a total of two cycles latency from setting buffer_point
// to being able to use the result of reading that DPRAM entry.
always @(posedge clk) case (mode)
	0: if (start) begin
		mode <= 1;
		buffer_point <= buf_start_addr;
	end
	1: begin
		mode <= 2;
		buffer_point <= buffer_point + 1;
	end
	2: begin
		mode <= 3;
		len_req_r <= host_d;
		odd_octet <= 0;
		req_r <= 1;
	end
	3: if (strobe) begin
		odd_octet <= ~odd_octet;
		buffer_point <= buffer_point + even_octet;
		len_req_r <= len_req_r-1;
		if (len_req_r == 1) begin
			mode <= 4;
			done_r <= 1;
			req_r <= 0;
		end
	end
	4: begin
		if (~start) begin
			mode <= 0;
			done_r <= 0;
		end
	end
endcase

assign host_addr = buffer_point;
assign len_req = len_req_r;
assign mac_data = (odd_octet^big_endian) ? host_d[15:8] : host_d[7:0];
assign done = done_r;
assign req = req_r;

endmodule
// Demo client
module hello(
	input clk,
	// client interface with RTEFI, see doc/clients.eps
	input [10:0] len_c,
	input [7:0] idata,
	input raw_l,
	input raw_s,
	output [7:0] odata
);

parameter n_lat=2;

reg [255:0] test_msg_rom = "Hello world from Packet Badger!\n";
reg [4:0] a;
reg [7:0] test_msg=0;
always @(posedge clk) begin
	a <= len_c[4:0] - 9;
	test_msg <= test_msg_rom[{a,3'b0} +: 8];
end

// 13 bits input, 8 bits output, choose to pipeline output
reg_delay #(.len(n_lat-2), .dw(8)) align(.clk(clk), .gate(1'b1), .reset(1'b0),
	.din(test_msg), .dout(odata));


endmodule
